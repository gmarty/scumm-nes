{"mappings":"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","sources":["<anon>","src/lib/parseRom.js","src/lib/parseRooms.js","src/lib/parser.js","src/lib/parseRoomGfx.js","src/lib/parsePreps.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire3956\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"i9q43\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $d36d4919f23def08$export$2e2bcd8739ae039);\n\nvar $ke1uA = parcelRequire(\"ke1uA\");\n\nvar $lfFYM = parcelRequire(\"lfFYM\");\n\nvar $5s9p1 = parcelRequire(\"5s9p1\");\nconst $d36d4919f23def08$var$parseRom = (arrayBuffer, res)=>{\n    const rooms = [];\n    const roomgfx = [];\n    const preps = [];\n    for(let i = 0; i < res.rooms.length; i++){\n        const [offset, length] = res.rooms[i];\n        if (length === 0) continue;\n        const buffer = arrayBuffer.slice(offset, offset + length);\n        const item = (0, $ke1uA.default)(buffer, i, offset, res.characters);\n        item.buffer = buffer;\n        rooms.push(item);\n    }\n    for(let i = 0; i < res.roomgfx.length; i++){\n        const [offset, length] = res.roomgfx[i];\n        const buffer = arrayBuffer.slice(offset, offset + length);\n        const item = (0, $lfFYM.default)(buffer, i, offset);\n        item.buffer = buffer;\n        roomgfx.push(item);\n    }\n    for(let i = 0; i < res.preplist.length; i++){\n        const [offset, length] = res.preplist[i];\n        const buffer = arrayBuffer.slice(offset, offset + length);\n        const item = (0, $5s9p1.default)(buffer, i, offset, res.characters);\n        item.buffer = buffer;\n        preps.push(item);\n    }\n    return {\n        rooms: rooms,\n        roomgfx: roomgfx,\n        preps: preps\n    };\n};\nvar $d36d4919f23def08$export$2e2bcd8739ae039 = $d36d4919f23def08$var$parseRom;\n\n});\nparcelRegister(\"ke1uA\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $eb9645d2dc5991ae$export$2e2bcd8739ae039);\n\nvar $6iSCY = parcelRequire(\"6iSCY\");\n\nvar $gkxcz = parcelRequire(\"gkxcz\");\nconst $eb9645d2dc5991ae$var$assert = console.assert;\nconst $eb9645d2dc5991ae$var$parseRooms = (arrayBuffer, i, offset = 0, characters = {})=>{\n    const parser = new (0, $6iSCY.default)(arrayBuffer);\n    const metadata = {\n        id: i,\n        offset: offset,\n        size: arrayBuffer.byteLength\n    };\n    const chunkSize = parser.getUint16(); // Room res size\n    $eb9645d2dc5991ae$var$assert(chunkSize === arrayBuffer.byteLength, \"Room res size flag does not match chunk size.\");\n    const unk1 = parser.getUint8();\n    const unk2 = parser.getUint8();\n    $eb9645d2dc5991ae$var$assert(unk1 === 0, \"Unknown 1 is not 0.\");\n    const width = parser.getUint16(); // Room width\n    const height = parser.getUint16(); // Room height\n    $eb9645d2dc5991ae$var$assert(width === 28 || width === 60, \"Room width is not 28 or 60.\");\n    $eb9645d2dc5991ae$var$assert(height === 16, \"Room height is not 16.\");\n    const unk3 = parser.getUint16(); // Number objects in room (unused?)\n    $eb9645d2dc5991ae$var$assert(unk3 === 0, \"Unknown 3 is not 0.\");\n    const nametableOffs = parser.getUint16(); // Gfx background tileset offset\n    const attrOffs = parser.getUint16(); // Gfx background attr offset\n    const maskOffs = parser.getUint16(); // Gfx mask offset\n    const unk4 = parser.getUint16(); // charMap offset\n    const unk5 = parser.getUint16(); // picMap offset\n    $eb9645d2dc5991ae$var$assert(unk4 === unk5, \"The values of unknown 4 and 5 do not match.\");\n    const objectsNum = parser.getUint8();\n    $eb9645d2dc5991ae$var$assert(objectsNum < 57, \"There are more than 56 objects in room.\");\n    const boxOffs = parser.getUint8();\n    const soundsNum = parser.getUint8();\n    $eb9645d2dc5991ae$var$assert(soundsNum === 0, \"The number of sounds is not 0.\");\n    const scriptsNum = parser.getUint8();\n    const excdOffs = parser.getUint16(); // Exit script (EXCD) offset\n    const encdOffs = parser.getUint16(); // Entry script (ENCD) offset\n    let map = [\n        {\n            type: \"header\",\n            from: 0x00,\n            to: 28\n        }\n    ];\n    const header = {\n        chunkSize: chunkSize,\n        unk1: unk1,\n        unk2: unk2,\n        width: width,\n        height: height,\n        unk3: unk3,\n        nametableOffs: nametableOffs,\n        attrOffs: attrOffs,\n        maskOffs: maskOffs,\n        unk4: unk4,\n        unk5: unk5,\n        objectsNum: objectsNum,\n        boxOffs: boxOffs,\n        soundsNum: soundsNum,\n        scriptsNum: scriptsNum,\n        excdOffs: excdOffs,\n        encdOffs: encdOffs\n    };\n    const objectImages = [];\n    const objects = [];\n    const boxes = [];\n    // These 2 are optional.\n    if (excdOffs > 0) map.push({\n        type: \"excdOffs\",\n        from: excdOffs,\n        to: encdOffs - 1\n    });\n    if (encdOffs > 0) map.push({\n        type: \"encdOffs\",\n        from: encdOffs,\n        to: chunkSize - 1\n    });\n    // Parse gfx nametable.\n    const nametableParser = new (0, $6iSCY.default)(arrayBuffer.slice(nametableOffs));\n    const tileset = nametableParser.getUint8();\n    const palette = [];\n    const nametableObj = Array(16);\n    for(let i = 0; i < 16; i++)palette[i] = nametableParser.getUint8();\n    for(let i = 0; i < 16; i++){\n        nametableObj[i] = Array(64).fill(0);\n        nametableObj[i][0] = 0;\n        nametableObj[i][1] = 0;\n        let n = 0;\n        while(n < width){\n            const loop = nametableParser.getUint8();\n            if (loop & 0x80) for(let j = 0; j < (loop & 0x7f); j++)nametableObj[i][2 + n++] = nametableParser.getUint8();\n            else {\n                const data = nametableParser.getUint8();\n                for(let j = 0; j < (loop & 0x7f); j++)nametableObj[i][2 + n++] = data;\n            }\n        }\n    }\n    const nametable = {\n        tileset: tileset,\n        palette: palette,\n        nametableObj: nametableObj\n    };\n    map.push({\n        type: \"nametable\",\n        from: nametableOffs,\n        to: nametableOffs + nametableParser.pointer - 1\n    });\n    $eb9645d2dc5991ae$var$assert(nametableOffs + nametableParser.pointer === attrOffs, \"name table overlaps on attributes table.\");\n    // Parse gfx attrtable.\n    const attrtableParser = new (0, $6iSCY.default)(arrayBuffer.slice(attrOffs));\n    const attributes = Array(64).fill(0);\n    for(let n = 0; n < 64;){\n        const loop = attrtableParser.getUint8();\n        if (loop & 0x80) for(let j = 0; j < (loop & 0x7f); j++)attributes[n++] = attrtableParser.getUint8();\n        else {\n            const data = attrtableParser.getUint8();\n            for(let j = 0; j < (loop & 0x7f); j++)attributes[n++] = data;\n        }\n        if (!(n & 7) && width === 0x1c) n += 8;\n    }\n    map.push({\n        type: \"attributes\",\n        from: attrOffs,\n        to: attrOffs + attrtableParser.pointer - 1\n    });\n    $eb9645d2dc5991ae$var$assert(attrOffs + attrtableParser.pointer === maskOffs, \"Attributes table overlaps on mask table.\");\n    // Parse gfx masktable.\n    const masktableParser = new (0, $6iSCY.default)(arrayBuffer.slice(maskOffs));\n    const hasMask = masktableParser.getUint8();\n    $eb9645d2dc5991ae$var$assert(hasMask === 0 || hasMask === 1, \"hasMask is neither 0 nor 1.\");\n    const masktable = {\n        hasMask: !!hasMask\n    };\n    if (hasMask === 1) {\n        let masktableObj = Array(16).fill([]);\n        let mwidth = masktableParser.getUint8();\n        for(i = 0; i < 16; i++){\n            masktableObj[i] = Array(8).fill(0);\n            let n = 0;\n            while(n < mwidth){\n                const loop = masktableParser.getUint8();\n                if (loop & 0x80) for(let j = 0; j < (loop & 0x7f); j++)masktableObj[i][n++] = masktableParser.getUint8();\n                else {\n                    const data = masktableParser.getUint8();\n                    for(let j = 0; j < (loop & 0x7f); j++)masktableObj[i][n++] = data;\n                }\n            }\n        }\n        masktable.masktableObj = masktableObj;\n        map.push({\n            type: \"masktable\",\n            from: maskOffs,\n            to: maskOffs + masktableParser.pointer - 1\n        });\n    } else map.push({\n        type: \"masktable\",\n        from: maskOffs,\n        to: maskOffs\n    });\n    // @todo Add a check to verify that the mask table doesn't overlap on object images.\n    // @todo Check what happens when objectsNum is 0.\n    if (objectsNum > 0) map.push({\n        type: \"objectImagesOffs\",\n        from: 0x1c,\n        to: 0x1c + objectsNum * 2\n    }, {\n        type: \"objectsOffs\",\n        from: 0x1c + objectsNum * 2,\n        to: 0x1c + objectsNum * 4 - 1\n    });\n    const objectImagesOffs = [];\n    const objectsOffs = [];\n    // @todo Set the end of the ArrayBuffer slice.\n    const objectImageOffsParser = new (0, $6iSCY.default)(arrayBuffer.slice(0x1c));\n    const objectOffsParser = new (0, $6iSCY.default)(arrayBuffer.slice(0x1c + objectsNum * 2));\n    for(let j = 0; j < objectsNum; j++){\n        objectImagesOffs.push(objectImageOffsParser.getUint16());\n        objectsOffs.push(objectOffsParser.getUint16());\n    }\n    // Calculate the earliest object offset. Used to discard empty object images.\n    const objectImagesStart = Math.min(...objectImagesOffs);\n    const objectsStart = Math.min(...objectsOffs);\n    // End rang values will be set later.\n    const objectImageMap = {\n        type: \"objectImages\",\n        from: objectImagesStart,\n        to: 0\n    };\n    const objectCodeMap = {\n        type: \"objects\",\n        from: objectsStart,\n        to: 0\n    };\n    for(let j = 0; j < objectsNum; j++){\n        const objectImageOffs = objectImagesOffs[j];\n        const objectOffs = objectsOffs[j];\n        // @todo Set the end of the ArrayBuffer slice.\n        const objectsParser = new (0, $6iSCY.default)(arrayBuffer.slice(objectOffs));\n        // Object content\n        const objectSize = objectsParser.getUint16();\n        const objUnk1 = objectsParser.getUint8();\n        const objUnk2 = objectsParser.getUint8();\n        $eb9645d2dc5991ae$var$assert(objUnk1 === 0, \"Unknown 1 is not 0.\");\n        $eb9645d2dc5991ae$var$assert(objUnk2 === 0, \"Unknown 2 is not 0.\");\n        const id = objectsParser.getUint16();\n        const objUnk3 = objectsParser.getUint8();\n        $eb9645d2dc5991ae$var$assert(objUnk3 === 0, \"Unknown 3 is not 0.\");\n        const objX = objectsParser.getUint8();\n        const byte1 = objectsParser.getUint8();\n        const objY = byte1 & 0x7f;\n        // assert(objX < width, 'Object is outside of room width.');\n        // assert(objY < height, 'Object is outside of room height.');\n        const objParentState = (byte1 & 0x80 ? 1 : 0) * 8;\n        const objWidth = objectsParser.getUint8();\n        const objParent = objectsParser.getUint8();\n        const objWalkToX = objectsParser.getUint8();\n        const objWalkToY = objectsParser.getUint8() & 0x1f;\n        const byte2 = objectsParser.getUint8();\n        const objActorDir = byte2 & 0x07;\n        const objHeight = (byte2 & 0xf8) / 8;\n        const objNameOffs = objectsParser.getUint8();\n        $eb9645d2dc5991ae$var$assert(!(objNameOffs % 2), \"Object name offset is an odd number.\");\n        $eb9645d2dc5991ae$var$assert(objNameOffs >= 16, \"Object name offset is less than 16.\");\n        $eb9645d2dc5991ae$var$assert(objNameOffs < 255, \"Object name offset is more than 255.\");\n        // Parse object name.\n        const objectNameParser = new (0, $6iSCY.default)(arrayBuffer.slice(objectOffs + objNameOffs, objectOffs + objectSize));\n        let objName = \"\";\n        let charCode = \"\";\n        try {\n            do {\n                charCode = objectNameParser.getUint8();\n                if (charCode === 0x00) break;\n                objName += (0, $gkxcz.decodeChar)(charCode, characters);\n            }while (objectNameParser.pointer < objectSize);\n        } catch (err) {\n            console.error(err);\n        }\n        // Parse object script offsets.\n        const objectScriptOffsParser = new (0, $6iSCY.default)(arrayBuffer.slice(objectOffs + 0x0f, objectOffs + objectSize));\n        const objScripts = [];\n        cur = 0x0f;\n        while(objectScriptOffsParser.pointer < objectSize){\n            const verbId = objectScriptOffsParser.getUint8();\n            if (verbId === 0) break;\n            objScripts.push([\n                verbId,\n                objectScriptOffsParser.getUint8()\n            ]);\n        }\n        // Parse object images.\n        let tiles;\n        if (objectImageOffs === objectsStart) tiles = null;\n        else {\n            // @todo Set the end of the ArrayBuffer slice.\n            const objectImagesParser = new (0, $6iSCY.default)(arrayBuffer.slice(objectImageOffs));\n            tiles = new Array(objHeight);\n            for(let i = 0; i < objHeight; i++){\n                tiles[i] = [];\n                let n = 0;\n                while(n < objWidth){\n                    const loop = objectImagesParser.getUint8();\n                    if (loop & 0x80) for(let j = 0; j < (loop & 0x7f); j++)tiles[i][n++] = objectImagesParser.getUint8();\n                    else {\n                        const data = objectImagesParser.getUint8();\n                        for(let j = 0; j < (loop & 0x7f); j++)tiles[i][n++] = data;\n                    }\n                }\n            }\n        }\n        // @todo Implement attribute changes and mask tables for object images.\n        objectImages.push({\n            tiles: tiles\n        });\n        // @fixme This does not account for object scripts.\n        if (objectCodeMap.to < objectOffs + cur) objectCodeMap.to = objectOffs + cur;\n        // Calculate the number of object script given the value of object name offset.\n        const calculatedObjScriptNum = (objNameOffs - 16) / 2;\n        $eb9645d2dc5991ae$var$assert(calculatedObjScriptNum === objScripts.length, \"Unknown data before object name offset.\");\n        objects.push({\n            size: objectSize,\n            objUnk1: objUnk1,\n            objUnk2: objUnk2,\n            num: id,\n            objUnk3: objUnk3,\n            x: objX,\n            y: objY,\n            parent: objParent,\n            parentState: objParentState,\n            width: objWidth,\n            height: objHeight,\n            walkToX: objWalkToX,\n            walkToY: objWalkToY,\n            actorDir: objActorDir,\n            nameOffs: objNameOffs,\n            name: objName,\n            objScripts: objScripts\n        });\n    }\n    $eb9645d2dc5991ae$var$assert(objectImages.length === objects.length, \"Length of object images and objects do not match.\");\n    // This is a hack.\n    objectImageMap.to = objectCodeMap.from - 1;\n    if (objectsNum > 0) map.push(objectCodeMap, objectImageMap);\n    // Parse boxes.\n    // @todo Set the end of the ArrayBuffer slice.\n    const boxesParser = new (0, $6iSCY.default)(arrayBuffer.slice(boxOffs));\n    const boxNum = boxesParser.getUint8();\n    for(let j = 0; j < boxNum; j++){\n        const uy = boxesParser.getUint8();\n        const ly = boxesParser.getUint8();\n        const ulx = boxesParser.getUint8();\n        const urx = boxesParser.getUint8();\n        const llx = boxesParser.getUint8();\n        const lrx = boxesParser.getUint8();\n        const mask = boxesParser.getUint8();\n        const flags = boxesParser.getUint8();\n        $eb9645d2dc5991ae$var$assert(mask === 0 || mask === 1, \"Box mask is neither 0 nor 1.\");\n        $eb9645d2dc5991ae$var$assert(flags === 0 || flags === 5, \"Box flag is neither 0 nor 5.\");\n        boxes.push({\n            uy: uy,\n            ly: ly,\n            ulx: ulx,\n            urx: urx,\n            llx: llx,\n            lrx: lrx,\n            mask: mask,\n            flags: flags\n        });\n    }\n    map.push({\n        type: \"boxes\",\n        from: boxOffs,\n        to: boxesParser.pointer - 1\n    });\n    const matrixSize = boxNum * (boxNum + 1);\n    const matrixMap = {\n        type: \"matrix\",\n        from: boxesParser.pointer - 1,\n        to: boxesParser.pointer - 1 + matrixSize\n    };\n    const matrix = [];\n    for(let j = 0; j < boxNum; j++)for(let k = 0; k < boxNum; k++)matrix.push(boxesParser.getUint8());\n    map.push(matrixMap);\n    // Order ROM map by starting offset.\n    map.sort((a, b)=>a.from - b.from);\n    return {\n        metadata: metadata,\n        header: header,\n        objectImagesOffs: objectImagesOffs,\n        objectsOffs: objectsOffs,\n        boxes: boxes,\n        matrix: matrix,\n        nametable: nametable,\n        attributes: attributes,\n        masktable: masktable,\n        objectImages: objectImages,\n        objects: objects,\n        hasMask: hasMask,\n        map: map\n    };\n};\nvar $eb9645d2dc5991ae$export$2e2bcd8739ae039 = $eb9645d2dc5991ae$var$parseRooms;\n\n});\nparcelRegister(\"6iSCY\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $496ecc65ed579085$export$2e2bcd8739ae039);\nclass $496ecc65ed579085$var$Parser {\n    #view;\n    #ptr = 0;\n    constructor(arrayBuffer){\n        this.#view = new DataView(arrayBuffer);\n    }\n    getUint8() {\n        return this.#view.getUint8(this.#ptr++);\n    }\n    getUint16() {\n        const val = this.#view.getUint16(this.#ptr, true);\n        this.#ptr += 2;\n        return val;\n    }\n    // Return the position of the next byte to read.\n    // @todo Return the last read character's instead.\n    get pointer() {\n        return this.#ptr;\n    }\n}\nvar $496ecc65ed579085$export$2e2bcd8739ae039 = $496ecc65ed579085$var$Parser;\n\n});\n\n\nparcelRegister(\"lfFYM\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $f78b8fe402633937$export$2e2bcd8739ae039);\n\nvar $6iSCY = parcelRequire(\"6iSCY\");\nconst $f78b8fe402633937$var$assert = console.assert;\nconst $f78b8fe402633937$var$parseRoomGfx = (arrayBuffer, i, offset = 0)=>{\n    const parser = new (0, $6iSCY.default)(arrayBuffer);\n    const metadata = {\n        id: i,\n        offset: offset,\n        size: arrayBuffer.byteLength,\n        decompressedSize: 0\n    };\n    const numberOfTiles = parser.getUint8();\n    const gfx = [];\n    while(parser.pointer < arrayBuffer.byteLength){\n        const loop = parser.getUint8();\n        if (loop & 0x80) for(let j = 0; j < (loop & 0x7f); j++)gfx.push(parser.getUint8());\n        else {\n            const data = parser.getUint8();\n            for(let j = 0; j < (loop & 0x7f); j++)gfx.push(data);\n        }\n    }\n    $f78b8fe402633937$var$assert(numberOfTiles === gfx.length / 8 / 2, \"Number of tiles byte does not match number of tiles decoded.\");\n    metadata.decompressedSize = gfx.length;\n    return {\n        metadata: metadata,\n        numberOfTiles: numberOfTiles,\n        gfx: gfx\n    };\n};\nvar $f78b8fe402633937$export$2e2bcd8739ae039 = $f78b8fe402633937$var$parseRoomGfx;\n\n});\n\nparcelRegister(\"5s9p1\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $3f86dc7278af9689$export$2e2bcd8739ae039);\n\nvar $6iSCY = parcelRequire(\"6iSCY\");\n\nvar $gkxcz = parcelRequire(\"gkxcz\");\nconst $3f86dc7278af9689$var$assert = console.assert;\nconst $3f86dc7278af9689$var$parsePreps = (arrayBuffer, i, offset = 0, characters = {})=>{\n    const parser = new (0, $6iSCY.default)(arrayBuffer);\n    const metadata = {\n        id: i,\n        offset: offset,\n        size: arrayBuffer.byteLength\n    };\n    const preps = [];\n    let charCode;\n    let prep = \"\";\n    for(let i = 0; i < arrayBuffer.byteLength; i++){\n        charCode = parser.getUint8();\n        if (charCode === 0x00) {\n            preps.push(prep);\n            prep = \"\";\n            continue;\n        }\n        prep += (0, $gkxcz.decodeChar)(charCode, characters);\n    }\n    $3f86dc7278af9689$var$assert(charCode === 0x00, \"The final character is not 0x00.\");\n    return {\n        metadata: metadata,\n        preps: preps\n    };\n};\nvar $3f86dc7278af9689$export$2e2bcd8739ae039 = $3f86dc7278af9689$var$parsePreps;\n\n});\n\n\n\n//# sourceMappingURL=parseRom.d53551bd.js.map\n","import parseRooms from '../lib/parseRooms';\nimport parseRoomGfx from '../lib/parseRoomGfx';\nimport parsePreps from './parsePreps';\n\nconst parseRom = (arrayBuffer, res) => {\n  const rooms = [];\n  const roomgfx = [];\n  const preps = [];\n\n  for (let i = 0; i < res.rooms.length; i++) {\n    const [offset, length] = res.rooms[i];\n\n    if (length === 0) {\n      continue;\n    }\n\n    const buffer = arrayBuffer.slice(offset, offset + length);\n    const item = parseRooms(buffer, i, offset, res.characters);\n    item.buffer = buffer;\n    rooms.push(item);\n  }\n\n  for (let i = 0; i < res.roomgfx.length; i++) {\n    const [offset, length] = res.roomgfx[i];\n\n    const buffer = arrayBuffer.slice(offset, offset + length);\n    const item = parseRoomGfx(buffer, i, offset);\n    item.buffer = buffer;\n    roomgfx.push(item);\n  }\n\n  for (let i = 0; i < res.preplist.length; i++) {\n    const [offset, length] = res.preplist[i];\n\n    const buffer = arrayBuffer.slice(offset, offset + length);\n    const item = parsePreps(buffer, i, offset, res.characters);\n    item.buffer = buffer;\n    preps.push(item);\n  }\n\n  return {\n    rooms,\n    roomgfx,\n    preps,\n  };\n};\n\nexport default parseRom;\n","import Parser from './parser';\nimport { decodeChar } from './utils';\n\nconst assert = console.assert;\n\nconst parseRooms = (arrayBuffer, i, offset = 0, characters = {}) => {\n  const parser = new Parser(arrayBuffer);\n  const metadata = {\n    id: i,\n    offset,\n    size: arrayBuffer.byteLength,\n  };\n\n  const chunkSize = parser.getUint16(); // Room res size\n\n  assert(\n    chunkSize === arrayBuffer.byteLength,\n    'Room res size flag does not match chunk size.',\n  );\n\n  const unk1 = parser.getUint8();\n  const unk2 = parser.getUint8();\n\n  assert(unk1 === 0, 'Unknown 1 is not 0.');\n\n  const width = parser.getUint16(); // Room width\n  const height = parser.getUint16(); // Room height\n\n  assert(width === 28 || width === 60, 'Room width is not 28 or 60.');\n  assert(height === 16, 'Room height is not 16.');\n\n  const unk3 = parser.getUint16(); // Number objects in room (unused?)\n\n  assert(unk3 === 0, 'Unknown 3 is not 0.');\n\n  const nametableOffs = parser.getUint16(); // Gfx background tileset offset\n  const attrOffs = parser.getUint16(); // Gfx background attr offset\n  const maskOffs = parser.getUint16(); // Gfx mask offset\n\n  const unk4 = parser.getUint16(); // charMap offset\n  const unk5 = parser.getUint16(); // picMap offset\n\n  assert(unk4 === unk5, 'The values of unknown 4 and 5 do not match.');\n\n  const objectsNum = parser.getUint8();\n\n  assert(objectsNum < 57, 'There are more than 56 objects in room.');\n\n  const boxOffs = parser.getUint8();\n  const soundsNum = parser.getUint8();\n\n  assert(soundsNum === 0, 'The number of sounds is not 0.');\n\n  const scriptsNum = parser.getUint8();\n  const excdOffs = parser.getUint16(); // Exit script (EXCD) offset\n  const encdOffs = parser.getUint16(); // Entry script (ENCD) offset\n\n  let map = [\n    {\n      type: 'header',\n      from: 0x00,\n      to: 0x1a + 2,\n    },\n  ];\n\n  const header = {\n    chunkSize,\n    unk1,\n    unk2,\n    width,\n    height,\n    unk3,\n    nametableOffs,\n    attrOffs,\n    maskOffs,\n    unk4,\n    unk5,\n    objectsNum,\n    boxOffs,\n    soundsNum,\n    scriptsNum,\n    excdOffs,\n    encdOffs,\n  };\n  const objectImages = [];\n  const objects = [];\n  const boxes = [];\n\n  // These 2 are optional.\n  if (excdOffs > 0) {\n    map.push({\n      type: 'excdOffs',\n      from: excdOffs,\n      to: encdOffs - 1, // Hack\n    });\n  }\n  if (encdOffs > 0) {\n    map.push({\n      type: 'encdOffs',\n      from: encdOffs,\n      to: chunkSize - 1, // Hack\n    });\n  }\n\n  // Parse gfx nametable.\n  const nametableParser = new Parser(arrayBuffer.slice(nametableOffs));\n\n  const tileset = nametableParser.getUint8();\n\n  const palette = [];\n  const nametableObj = Array(16);\n  for (let i = 0; i < 16; i++) {\n    palette[i] = nametableParser.getUint8();\n  }\n  for (let i = 0; i < 16; i++) {\n    nametableObj[i] = Array(64).fill(0);\n    nametableObj[i][0] = 0;\n    nametableObj[i][1] = 0;\n    let n = 0;\n    while (n < width) {\n      const loop = nametableParser.getUint8();\n      if (loop & 0x80) {\n        for (let j = 0; j < (loop & 0x7f); j++) {\n          nametableObj[i][2 + n++] = nametableParser.getUint8();\n        }\n      } else {\n        const data = nametableParser.getUint8();\n        for (let j = 0; j < (loop & 0x7f); j++) {\n          nametableObj[i][2 + n++] = data;\n        }\n      }\n    }\n  }\n\n  const nametable = {\n    tileset,\n    palette,\n    nametableObj,\n  };\n\n  map.push({\n    type: 'nametable',\n    from: nametableOffs,\n    to: nametableOffs + nametableParser.pointer - 1,\n  });\n\n  assert(\n    nametableOffs + nametableParser.pointer === attrOffs,\n    'name table overlaps on attributes table.',\n  );\n\n  // Parse gfx attrtable.\n  const attrtableParser = new Parser(arrayBuffer.slice(attrOffs));\n\n  const attributes = Array(64).fill(0);\n  for (let n = 0; n < 64; ) {\n    const loop = attrtableParser.getUint8();\n    if (loop & 0x80) {\n      for (let j = 0; j < (loop & 0x7f); j++) {\n        attributes[n++] = attrtableParser.getUint8();\n      }\n    } else {\n      const data = attrtableParser.getUint8();\n      for (let j = 0; j < (loop & 0x7f); j++) {\n        attributes[n++] = data;\n      }\n    }\n    if (!(n & 7) && width === 0x1c) {\n      n += 8;\n    }\n  }\n\n  map.push({\n    type: 'attributes',\n    from: attrOffs,\n    to: attrOffs + attrtableParser.pointer - 1,\n  });\n\n  assert(\n    attrOffs + attrtableParser.pointer === maskOffs,\n    'Attributes table overlaps on mask table.',\n  );\n\n  // Parse gfx masktable.\n  const masktableParser = new Parser(arrayBuffer.slice(maskOffs));\n\n  const hasMask = masktableParser.getUint8();\n\n  assert(hasMask === 0 || hasMask === 1, 'hasMask is neither 0 nor 1.');\n\n  const masktable = {\n    hasMask: !!hasMask,\n  };\n\n  if (hasMask === 1) {\n    let masktableObj = Array(16).fill([]);\n    let mwidth = masktableParser.getUint8();\n    for (i = 0; i < 16; i++) {\n      masktableObj[i] = Array(8).fill(0);\n      let n = 0;\n      while (n < mwidth) {\n        const loop = masktableParser.getUint8();\n        if (loop & 0x80) {\n          for (let j = 0; j < (loop & 0x7f); j++) {\n            masktableObj[i][n++] = masktableParser.getUint8();\n          }\n        } else {\n          const data = masktableParser.getUint8();\n          for (let j = 0; j < (loop & 0x7f); j++) {\n            masktableObj[i][n++] = data;\n          }\n        }\n      }\n    }\n\n    masktable.masktableObj = masktableObj;\n\n    map.push({\n      type: 'masktable',\n      from: maskOffs,\n      to: maskOffs + masktableParser.pointer - 1,\n    });\n  } else {\n    map.push({\n      type: 'masktable',\n      from: maskOffs,\n      to: maskOffs,\n    });\n  }\n\n  // @todo Add a check to verify that the mask table doesn't overlap on object images.\n\n  // @todo Check what happens when objectsNum is 0.\n  if (objectsNum > 0) {\n    map.push(\n      {\n        type: 'objectImagesOffs',\n        from: 0x1c,\n        to: 0x1c + objectsNum * 2,\n      },\n      {\n        type: 'objectsOffs',\n        from: 0x1c + objectsNum * 2,\n        to: 0x1c + objectsNum * 4 - 1,\n      },\n    );\n  }\n\n  const objectImagesOffs = [];\n  const objectsOffs = [];\n\n  // @todo Set the end of the ArrayBuffer slice.\n  const objectImageOffsParser = new Parser(arrayBuffer.slice(0x1c));\n  const objectOffsParser = new Parser(arrayBuffer.slice(0x1c + objectsNum * 2));\n\n  for (let j = 0; j < objectsNum; j++) {\n    objectImagesOffs.push(objectImageOffsParser.getUint16());\n    objectsOffs.push(objectOffsParser.getUint16());\n  }\n\n  // Calculate the earliest object offset. Used to discard empty object images.\n  const objectImagesStart = Math.min(...objectImagesOffs);\n  const objectsStart = Math.min(...objectsOffs);\n\n  // End rang values will be set later.\n  const objectImageMap = {\n    type: 'objectImages',\n    from: objectImagesStart,\n    to: 0,\n  };\n  const objectCodeMap = {\n    type: 'objects',\n    from: objectsStart,\n    to: 0,\n  };\n\n  for (let j = 0; j < objectsNum; j++) {\n    const objectImageOffs = objectImagesOffs[j];\n    const objectOffs = objectsOffs[j];\n\n    // @todo Set the end of the ArrayBuffer slice.\n    const objectsParser = new Parser(arrayBuffer.slice(objectOffs));\n\n    // Object content\n    const objectSize = objectsParser.getUint16();\n    const objUnk1 = objectsParser.getUint8();\n    const objUnk2 = objectsParser.getUint8();\n\n    assert(objUnk1 === 0, 'Unknown 1 is not 0.');\n    assert(objUnk2 === 0, 'Unknown 2 is not 0.');\n\n    const id = objectsParser.getUint16();\n    const objUnk3 = objectsParser.getUint8();\n\n    assert(objUnk3 === 0, 'Unknown 3 is not 0.');\n\n    const objX = objectsParser.getUint8();\n    const byte1 = objectsParser.getUint8();\n    const objY = byte1 & 0x7f;\n\n    // assert(objX < width, 'Object is outside of room width.');\n    // assert(objY < height, 'Object is outside of room height.');\n\n    const objParentState = (byte1 & 0x80 ? 1 : 0) * 8;\n    const objWidth = objectsParser.getUint8();\n    const objParent = objectsParser.getUint8();\n    const objWalkToX = objectsParser.getUint8();\n    const objWalkToY = objectsParser.getUint8() & 0x1f;\n    const byte2 = objectsParser.getUint8();\n    const objActorDir = byte2 & 0x07;\n    const objHeight = (byte2 & 0xf8) / 8;\n\n    const objNameOffs = objectsParser.getUint8();\n\n    assert(!(objNameOffs % 2), 'Object name offset is an odd number.');\n    assert(objNameOffs >= 16, 'Object name offset is less than 16.');\n    assert(objNameOffs < 255, 'Object name offset is more than 255.');\n\n    // Parse object name.\n    const objectNameParser = new Parser(\n      arrayBuffer.slice(objectOffs + objNameOffs, objectOffs + objectSize),\n    );\n    let objName = '';\n    let charCode = '';\n    try {\n      do {\n        charCode = objectNameParser.getUint8();\n        if (charCode === 0x00) {\n          break;\n        }\n        objName += decodeChar(charCode, characters);\n      } while (objectNameParser.pointer < objectSize);\n    } catch (err) {\n      console.error(err);\n    }\n\n    // Parse object script offsets.\n    const objectScriptOffsParser = new Parser(\n      arrayBuffer.slice(objectOffs + 0x0f, objectOffs + objectSize),\n    );\n    const objScripts = [];\n    cur = 0x0f;\n    while (objectScriptOffsParser.pointer < objectSize) {\n      const verbId = objectScriptOffsParser.getUint8();\n      if (verbId === 0) {\n        // End of objects scripts (usually beginning of name offset).\n        break;\n      }\n      objScripts.push([verbId, objectScriptOffsParser.getUint8()]);\n    }\n\n    // Parse object images.\n    let tiles;\n    if (objectImageOffs === objectsStart) {\n      tiles = null;\n    } else {\n      // @todo Set the end of the ArrayBuffer slice.\n      const objectImagesParser = new Parser(arrayBuffer.slice(objectImageOffs));\n      tiles = new Array(objHeight);\n      for (let i = 0; i < objHeight; i++) {\n        tiles[i] = [];\n        let n = 0;\n        while (n < objWidth) {\n          const loop = objectImagesParser.getUint8();\n          if (loop & 0x80) {\n            for (let j = 0; j < (loop & 0x7f); j++) {\n              tiles[i][n++] = objectImagesParser.getUint8();\n            }\n          } else {\n            const data = objectImagesParser.getUint8();\n            for (let j = 0; j < (loop & 0x7f); j++) {\n              tiles[i][n++] = data;\n            }\n          }\n        }\n      }\n    }\n\n    // @todo Implement attribute changes and mask tables for object images.\n\n    objectImages.push({ tiles });\n\n    // @fixme This does not account for object scripts.\n    if (objectCodeMap.to < objectOffs + cur) {\n      objectCodeMap.to = objectOffs + cur;\n    }\n\n    // Calculate the number of object script given the value of object name offset.\n    const calculatedObjScriptNum = (objNameOffs - 16) / 2;\n    assert(\n      calculatedObjScriptNum === objScripts.length,\n      'Unknown data before object name offset.',\n    );\n\n    objects.push({\n      size: objectSize,\n      objUnk1,\n      objUnk2,\n      num: id,\n      objUnk3,\n      x: objX,\n      y: objY,\n      parent: objParent,\n      parentState: objParentState,\n      width: objWidth,\n      height: objHeight,\n      walkToX: objWalkToX,\n      walkToY: objWalkToY,\n      actorDir: objActorDir,\n      nameOffs: objNameOffs,\n      name: objName,\n      objScripts,\n    });\n  }\n\n  assert(\n    objectImages.length === objects.length,\n    'Length of object images and objects do not match.',\n  );\n\n  // This is a hack.\n  objectImageMap.to = objectCodeMap.from - 1;\n\n  if (objectsNum > 0) {\n    map.push(objectCodeMap, objectImageMap);\n  }\n\n  // Parse boxes.\n  // @todo Set the end of the ArrayBuffer slice.\n  const boxesParser = new Parser(arrayBuffer.slice(boxOffs));\n  const boxNum = boxesParser.getUint8();\n\n  for (let j = 0; j < boxNum; j++) {\n    const uy = boxesParser.getUint8();\n    const ly = boxesParser.getUint8();\n    const ulx = boxesParser.getUint8();\n    const urx = boxesParser.getUint8();\n    const llx = boxesParser.getUint8();\n    const lrx = boxesParser.getUint8();\n    const mask = boxesParser.getUint8();\n    const flags = boxesParser.getUint8();\n\n    assert(mask === 0 || mask === 1, 'Box mask is neither 0 nor 1.');\n    assert(flags === 0 || flags === 5, 'Box flag is neither 0 nor 5.');\n\n    boxes.push({ uy, ly, ulx, urx, llx, lrx, mask, flags });\n  }\n\n  map.push({\n    type: 'boxes',\n    from: boxOffs,\n    to: boxesParser.pointer - 1,\n  });\n\n  const matrixSize = boxNum * (boxNum + 1);\n  const matrixMap = {\n    type: 'matrix',\n    from: boxesParser.pointer - 1,\n    to: boxesParser.pointer - 1 + matrixSize,\n  };\n  const matrix = [];\n  for (let j = 0; j < boxNum; j++) {\n    for (let k = 0; k < boxNum; k++) {\n      matrix.push(boxesParser.getUint8());\n    }\n  }\n\n  map.push(matrixMap);\n\n  // Order ROM map by starting offset.\n  map.sort((a, b) => a.from - b.from);\n\n  return {\n    metadata,\n    header,\n    objectImagesOffs,\n    objectsOffs,\n    boxes,\n    matrix,\n    nametable,\n    attributes,\n    masktable,\n    objectImages,\n    objects,\n    hasMask,\n    map,\n  };\n};\n\nexport default parseRooms;\n","class Parser {\n  #view;\n  #ptr = 0;\n\n  constructor(arrayBuffer) {\n    this.#view = new DataView(arrayBuffer);\n  }\n\n  getUint8() {\n    return this.#view.getUint8(this.#ptr++);\n  }\n\n  getUint16() {\n    const val = this.#view.getUint16(this.#ptr, true);\n    this.#ptr += 2;\n    return val;\n  }\n\n  // Return the position of the next byte to read.\n  // @todo Return the last read character's instead.\n  get pointer() {\n    return this.#ptr;\n  }\n}\n\nexport default Parser;\n","import Parser from './parser';\n\nconst assert = console.assert;\n\nconst parseRoomGfx = (arrayBuffer, i, offset = 0) => {\n  const parser = new Parser(arrayBuffer);\n  const metadata = {\n    id: i,\n    offset,\n    size: arrayBuffer.byteLength,\n    decompressedSize: 0,\n  };\n\n  const numberOfTiles = parser.getUint8();\n\n  const gfx = [];\n  while (parser.pointer < arrayBuffer.byteLength) {\n    const loop = parser.getUint8();\n    if (loop & 0x80) {\n      for (let j = 0; j < (loop & 0x7f); j++) {\n        gfx.push(parser.getUint8());\n      }\n    } else {\n      const data = parser.getUint8();\n      for (let j = 0; j < (loop & 0x7f); j++) {\n        gfx.push(data);\n      }\n    }\n  }\n\n  assert(\n    numberOfTiles === gfx.length / 8 / 2,\n    'Number of tiles byte does not match number of tiles decoded.',\n  );\n\n  metadata.decompressedSize = gfx.length;\n\n  return {\n    metadata,\n    numberOfTiles,\n    gfx,\n  };\n};\n\nexport default parseRoomGfx;\n","import Parser from './parser';\nimport { decodeChar } from './utils';\n\nconst assert = console.assert;\n\nconst parsePreps = (arrayBuffer, i, offset = 0, characters = {}) => {\n  const parser = new Parser(arrayBuffer);\n  const metadata = {\n    id: i,\n    offset,\n    size: arrayBuffer.byteLength,\n  };\n\n  const preps = [];\n  let charCode;\n  let prep = '';\n\n  for (let i = 0; i < arrayBuffer.byteLength; i++) {\n    charCode = parser.getUint8();\n    if (charCode === 0x00) {\n      preps.push(prep);\n      prep = '';\n      continue;\n    }\n\n    prep += decodeChar(charCode, characters);\n  }\n\n  assert(charCode === 0x00, 'The final character is not 0x00.');\n\n  return {\n    metadata,\n    preps,\n  };\n};\n\nexport default parsePreps;\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$d36d4919f23def08$export$2e2bcd8739ae039","$ke1uA","$lfFYM","$5s9p1","arrayBuffer","res","rooms","roomgfx","preps","i","length","offset","buffer","slice","item","default","characters","push","preplist","$eb9645d2dc5991ae$export$2e2bcd8739ae039","$6iSCY","$gkxcz","$eb9645d2dc5991ae$var$assert","console","assert","parser","metadata","id","size","byteLength","chunkSize","getUint16","unk1","getUint8","unk2","width","height","unk3","nametableOffs","attrOffs","maskOffs","unk4","unk5","objectsNum","boxOffs","soundsNum","scriptsNum","excdOffs","encdOffs","map","type","from","to","objectImages","objects","boxes","nametableParser","tileset","palette","nametableObj","Array","fill","loop","j","data","pointer","attrtableParser","attributes","masktableParser","hasMask","masktable","masktableObj","mwidth","objectImagesOffs","objectsOffs","objectImageOffsParser","objectOffsParser","objectsStart","Math","min","objectImageMap","objectCodeMap","tiles","objectImageOffs","objectOffs","objectsParser","objectSize","objUnk1","objUnk2","objUnk3","objX","byte1","objY","objParentState","objWidth","objParent","objWalkToX","objWalkToY","byte2","objActorDir","objHeight","objNameOffs","objectNameParser","objName","charCode","decodeChar","err","error","objectScriptOffsParser","objScripts","cur","verbId","objectImagesParser","calculatedObjScriptNum","num","x","y","parent","parentState","walkToX","walkToY","actorDir","nameOffs","name","boxesParser","boxNum","uy","ly","ulx","urx","llx","lrx","mask","flags","matrixMap","matrix","k","sort","a","b","header","nametable","$496ecc65ed579085$export$2e2bcd8739ae039","view","ptr","constructor","DataView","val","$f78b8fe402633937$export$2e2bcd8739ae039","$f78b8fe402633937$var$assert","decompressedSize","numberOfTiles","gfx","$3f86dc7278af9689$export$2e2bcd8739ae039","$3f86dc7278af9689$var$assert","prep"],"version":3,"file":"parseRom.d53551bd.js.map"}